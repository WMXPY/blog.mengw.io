---
layout: post
title:  "Hashmap.size >= Large"
categories: blog
description: 面试之前请你再看一遍哈希表结构！
---

## 面试之前还要看一遍这个？

当你从学校毕业，觉得这些学校教的东西真是没有用的时候。  
当你严肃编程，觉得学校教的这些东西真的令人深思的时候。  
当你不断练习，觉得简单的结构对你清晰明了，完全理解的时候。  
你会发现还是得背下来。

## 背景故事

我们都知道哈希表的运作原理，也应该都从各个地方看过所谓剖析某语言的哈希表实现。但是上次面试的时候我被问到了一个问题：

> 如果散列值重复了怎么办？

有经验的小朋友肯定是不以为然的，当然是存在同一个 slot 里面以后遇到了再去一个一个试啊。我也是这么回答的，然后他问我是：

> 用什么形式存在里面的？

这个问题也很容易回答，我们都知道是链表，然后他问链表里面每一个元素都是什么形式的。。。  
总之，这篇文章算是帮你我把这个（没什么用的）知识点背下来。

## 散列值冲突了

这个时候，还是 Java 的实现有帮助，源码我就不放了，简单解释一下。

Java 的哈希表是一个表形式，每一个表里面的类型都是相同的，也就是 `Entity` 这是一个类，包含整个 `key`, `value` 和 `hash` 的内容，同时可以被当作链表的节点使用。在散列值不同的情况下，对应的 Entity 会被储存。而在散列值相同的情况下，新的元素会直接覆盖原来对应散列值位置的 Entity 并且将自己的子元素的指针指向之前的 Entity。这种实现的好处是在链表形式的情况下不需要考虑是否为第一个元素，即使作为唯一散列值的 Entity 元素也可以直接将自己的子元素用同样的方法指向之前该位置的对象，也就是 null。

后续这篇文章应该会更新哈希表空间不足的问题。
